---
hip: 100
title: Signature and Wallet Providers
author: Daniel Akhteorv <daniel@launchbadge.com>
type: Standards Track
category: Application
needs-council-approval: Yes
status: Draft
created: 2022-01-20
discussions-to: TBD
updated: 2022-01-20
---

## **Abstract**

Ethereum like signature and wallet providers with the Hedera SDKs

## **Motivation**

Cryptocurrency users are more used to Ethereum's signature and wallet providers instead
of direclty hardcoding private keys into their projects. Supporting third party signature
and wallet provider would be better for security and user experience.

## **Specification**

<details>
<summary>abstract class Signer</summary>
  
### Methods

##### `async signMessage` ( `messages`: `List` < `bytes` > ): `List` < `List` < `SignerSignature` > >

Sign a list of messages

**NOTE**: Each element in the outer list of the result is all the signatures for the
message at the same index.

---

##### `async signTransaction` ( `transaction`: `Transaction` )

Signs the transaction

**NOTE**: Use `Transaction.getSignatures()` to see the actual signatures.
message at the same index.

---

##### `async sendTransaction` ( `transaction`: `Transaction` ): `TransactionReceipt`

Sign and send a transaction using the wallet

**NOTE**: Unlike `Provider.sendTransaction()` this method will automatically wait for
the receipt of the transaction.

---

##### `async checkTransaction` ( `transaction`: `Transaction` )

Determines if all the properties requried are set and sets the transaction ID. If the transaction ID was already set it checks if the account ID of it is the same as the users.

---

##### `async populateTransaction` ( `transaction`: `Transaction` )

Sets the transaction ID of the transaction to the current account ID of the signer.

---

##### `getLedgerId` (): `LedgerId`

Return the ledger ID

---

##### `getAccountId` (): `AccountID`

Return the account ID associated with this signer

---

##### `async getAccountBalance` (): `AccountBalance`

Fetch the account's balance

---

##### `async getAccountInfo` (): `AccountInfo`

Fetch the account's info

---

##### `async getTransactionRecords` (): `List` < `TransactionRecord` >

Fetch the last transaction records for this account using `TransactionRecordQuery`

---

##### `async getTransactionRecords` (): `List` < `TransactionRecord` >

Fetch the last transaction records for this account using `TransactionRecordQuery`

---
</details>

<details>
<summary>abstract class Provider</summary>

> abstract class `Provider`

### Methods

##### `getLedgerId` (): `LedgerId`

Return the ID of the current network

---

##### `async getAccountBalance` ( `accountId`: `AccountId` ): `AccountBalance`

Get the balance for an account

---

##### `async getAccountInfo` ( `accountId`: `AccountId` ): `AccountInfo`

Get the info for an account

---

##### `async getTransactionReceipt` ( `transactionId`: `TransactionId` ): `TransacitonReceipt`

Get a receipt for a transaction ID

---

##### `async sendTransaction` ( `transaction`: `Transaction` ): `TransactionResponse`

Sign and send a transaction using the wallet

---

##### `async waitForReceipt` ( `response`: `TransactionResponse` ): `TransactionReceipt`

Wait for the receipt for a transaction response

**NOTE**: This is different than `getTransactionReceipt()` this method requires a `nodeId` which
is set inside `TransactionResponse` and as a result should not be able to fail with `RECEIPT_NOT_FOUND`

---
</details>

<details>
<summary>abstract class Wallet extends Signer</summary>

### Static Methods

##### `withPrivateKey` ( `privateKey`: `PrivateKey` ): `Wallet`

Create a wallet using a private key

---

### Methods

##### `getProvider` (): `Provider`

Return the provider

---

##### `getPublicKey` (): `PublicKey`

Return the public key associated with this wallet.

---

##### `async createRandomED25519` (): `Wallet`

Creates a wallet with a new ED25519 key

**NOTE**: This would create an alias key account on Hedera

---

##### `async createRandomECDSA` (): `Wallet`

Creates a wallet with a new ECDSA key

**NOTE**: This would create an alias key account on Hedera

---
</details>

<details>
<summary>class SignerSignature</summary>

### Fields

##### `publicKey`: `PublicKey`

The public key that signed this request

---

##### `signature`: `bytes`

The siganture for the message

---

##### `accountId`: `AccountId`

The account ID associated with the public key which signed the transaction

**NOTE**: This account ID may be repeated multiple times if an account uses a `KeyList` or `ThresholdKey`

---
</details>

<details>
<summary>class LocalWallet implements Wallet</summary>

### Static Methods

### Constructor

##### `constructor`()

Creates an `LocalWallet` from the environment variables `OPERATOR_KEY`, `OPERATOR_ID`, and `HEDERA_NEWTORK`

---

### Methods

##### async `sign` ( `messages`: `List` < `bytes` > ): `List` < `List` < `SignatureProviderSignature` > >

Signs all the messages with all the private keys.

---
</details>

<details>
<summary>class VoidSigner extends Signer</summary>

### Static Methods

##### `withAccountId` ( `accountId`: `AccountId` ): `VoidSigner`

Create a wallet using a private key

---

### Methods

##### `getProvider` (): `Provider`

Return the provider

---

##### `getPublicKey` (): `PublicKey`

Will return `null`

---

##### `async signTransaction` ( `transaction`: `Transaction` )

Will do nothing

---

##### `async sendTransaction` ( `transaction`: `Transaction` ): `TransactionReceipt`

Will throw an error as sending a transaction using a `VoidSigner` is not supported.

---
</details>

The difference between `Signer` and `Provider` is the `Signer` signs requests while `Provider` provides
the network to which this request should be submitted to.

<details>
<summary>MyHbarWallet Example</summary>

```typescript
// Only accessible from within the browser environment after logging into MyHbarWallet
class MyHbarWalletTestnetWallet {
    private privateKey: PrivateKey;
    private accountId: AccountId;
    private provider: MyHbarWalletTestnetProvider = new MyHbarWalletTestnetProvider();
    
    constructor(privateKey: PrivateKey, accountId: AccountId | null) {
        this.privateKey = privateKey;
        this.accountId = accountId != null
            ? accountId
            : privateKey.publicKey.toAccountId(0, 0);
    }
    
    static withPrivateKey(privateKey: PrivateKey): Wallet {
        return new MyHbarWalletTestnetWallet(privateKey);
    }

    // MyHbarWallet could add such a method to make it easy to get the wallet
    // for the currently logged in user.
    static getCurrent(): MyHbarWalletTestnetWallet {
        // ...
    }
    
    getProvider(): Provider {
        return this.provider;
    }
    
    getPublicKey(): PublicKey {
        return this.privateKey.publicKey;
    }
    
    static async createRandomED25519(): Promise<MyHbarWalletTestnetWallet> {
        return MyHbarWalletTestnetWallet(await PrivateKey.generateED25519Async());    
    }

    static async createRandomECDSA(): Promise<MyHbarWalletTestnetWallet> {
        return MyHbarWalletTestnetWallet(await PrivateKey.generateECDSA());
    }
    
    async signMessage(messages: Uint8Array[]): Promise<SignerSignature[][]> {
        return Promise.resolve(messages.map((message) => {
           return [this.privateKey.sign(message)]; 
        }));
    }

    async sendTransaction(messages: Uint8Array[]): Promise<TransactionReceipt> {
        const response = await this.provider.sendTransaction(transaction);
        return this.provider.waitForReceipot(response);
    }
    
    async checkTransaction(transaction: Transaction) {
        return Promise.resovle(() => {
            const transactionId = transaction.transactionId;

            if (transactionId != null && transactionId.accountId.toString() != this.accountId.toString()) {
                throw new Error("TransactionID already set to a different account");
            }

            const nodeAccountIds = transaction.nodeAccountIds
                .map((nodeAccountId) => nodeAccountId.toString());
            const network = Object.values(this.provider.client.network)
                .map((nodeAccountId) => nodeAccountId.toString());

            if (!nodeAccountIds.reduce((previous, current) => previous && network.includes(current), true)) {
                throw new Error("Transaction already set node account IDs to values not within the current network");
            }
        });
    }
    
    async populateTransaction(transaction: Transaction) {
        await this.checkTransaction(transaction);
        
        transaction.setTransactionId(Transaction.generate(this.accountId));
        transaction.setNodeAccountIds(Object.values(this.provider.client.network));
    }
    
    getLedgerId(): LedgerId {
        return this.provider.getLedgerId();
    }
    
    getAccountId(): AccountId {
        return this.accountId;
    }
    
    getAccountBalance(accountId: AccountID): Promise<AccountBalance> {
        return this.provider.getAccountBalance(accountId);
    }

    getAccountInfo(accountId: AccountID): Promise<AccountInfo> {
        return this.provider.getAccounInfo(accountId);
    }

    getAccountRecords(accountId: AccountID): Promise<TransactionRecord[]> {
        return this.provider.getAccountRecords(accountId);
    }
}

class MyHbarWalletTestnetProvider {
    private client: Client = Client.forTestnet();
    
    constructor() {
    }
    
    getLedgerId(): LedgerId {
        return client.getLedgerId();
    }
    
    getAccountBalance(accountId: AccountID): Promise<AccountBalance> {
        return new AccountBalanceQuery()
            .setAccountId(accountId)
            .execute(this.client);
    }

    getAccountInfo(accountId: AccountID): Promise<AccountInfo> {
        return new AccountInfoQuery()
            .setAccountId(accountId)
            .execute(this.client);
    }

    getAccountRecords(accountId: AccountID): Promise<TransactionRecord[]> {
        return new AccountRecordsQuery()
            .setAccountId(accountId)
            .execute(this.client);
    }

    sendTransaction(transaction: Transaction): Promise<TransactionResponse> {
        return transaction.execute(this.client);
    }
    
    waitForReceipot(response: TransactionResponse): Promise<TransactionReceipt> {
        return response.getReceipt(this.client);
    }
}

const wallet = MyHbarWalletTestnetWallet.getCurrent();

async function main() {
    const balance = await wallet.getAccountBalance(wallet.accountId);
    console.log(`Current Balance for account: ${wallet.accountId.toString()} is ${balance.toString()}`);
}
```
</details>

## **Backwards Compatibility**

This is 100% backwards compatible

## **Security Implications**

WIP: [hethers.js](https://github.com/hashgraph/hethers.js/issues)

## **How to Teach This**

N/A

## **Reference Implementation**

N/A

## **Rejected Ideas**

N/A

## **Open Issues**

N/A

## **References**

## **Copyright/license**

This document is licensed under the Apache License, Version 2.0 -- see [LICENSE](https://github.com/hashgraph/hedera-improvement-proposal/LICENSE) or ([https://www.apache.org/licenses/LICENSE-2.0](https://www.apache.org/licenses/LICENSE-2.0))
