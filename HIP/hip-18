- hip: 18 
- title: Custom Hedera Token Service Fees
- author: Cooper Kunz <cooper@calaxy.com>, Rahul Kothari <rahul.kothari.201@gmail.com>
- type: Standard
- category: Service
- status: Draft
- created: 2021-04-30
- discussions-to: https://github.com/hashgraph/hedera-improvement-proposal/discussions/90
- updated: 2021-05-18

## Abstract
We propose adding a limited set of functionality to the Hedera Token Service (HTS) that allows developers to define custom fees between different tokens at time of creation, or at a later modification date with Hedera’s controlled mutability ([1](https://hedera.com/blog/code-is-law-but-what-if-the-law-needs-to-change)). These custom token fees will enable dynamic ecosystem fees as we see with projects such as Uniswap ([2](https://uniswap.org/docs/v2/protocol-overview/how-uniswap-works/)), or even Hedera itself ([3](https://hedera.com/hh_whitepaper_v2.1-20200815.pdf)). Additional implementations could even allow implementation of custom, and if desired, perpetual royalties ([4](https://messari.io/article/explain-it-like-i-am-5-nfts)), for any token issued on HTS, whether fungible or non-fungible.

## Motivation
In order to build a robust and sufficiently decentralized ecosystem, where no single entity can control community fees, or otherwise, developers need to be able to programmatically define and control fee relationships between various tokens issued on Hedera. Currently, the Hedera Token Service allows developers to easily configure, issue, and administer various types of cryptocurrencies, or tokens ([5](https://hedera.com/hh_tokenization-whitepaper_v2_20210101.pdf)).  However, there is currently very limited programmability, and HTS is not supported within Hedera Smart Contracts ([6](https://docs.hedera.com/guides/docs/sdks/tokens/define-a-token)), nor implemented within a layer 2 application/business network running on the Hedera Consensus Service ([7](https://github.com/hashgraph/hedera-improvement-proposal/issues/33)). 

In practice, this may look something like creating a “protocol” or “ecosystem” token for a given service. The ecosystem may have dozens, or potentially hundreds of “related” or “sub” tokens, generated by different entities. By defining a custom token relationship (i.e. a token fee schedule) for each of the related tokens at the time of its creation, we can guarantee that the protocol or ecosystem token is able to capture value and distribute it trustlessly to various ecosystem participants. Without this functionality there is no true “on-chain”, or in Hedera’s case, “on ledger”, way to ensure that all future transactions of a given token are associated with a protocol or native token, or similarly royalties for an NFT are going to the appropriate party.

To provide a concrete example, there may be a protocol token called $PROTOCOL_GAS, which is required to be held by everyone participating in an ecosystem. Any tokens created within this ecosystem can have various amounts of $PROTOCOL_GAS, attached to them. So in order to send {protocol-token-1} to a user, they could, for example, attach 1 $PROTOCOL_GAS token to send to {entity-1}, 2 $PROTOCOL_GAS tokens to {entity-2}, and 3 $PROTOCOL_GAS tokens to {entity-3}, then each entity, e.g. a DAO, can do whatever they wish with the fees accumulated. 

## Rationale
We believe and emphasize that this needs to be done natively on Hedera’s ledger via the Token Service, or some type of scripting language, and not at a layer 2 or via an application network to ensure that it has the same immutability characteristics and deterministic functionality required for things like 3rd party cryptocurrency exchange listings and 3rd party wallet support. Certainly there are fancy cryptographic ways to get around this with multisignature and/or multiparty transfers, or some mythical implementation of Hedera’s newly released scheduled transactions ([8](https://docs.hedera.com/guides/core-concepts/scheduled-transaction)), but this is a notably better user experience for both developers and end users.

Currently each transaction on Hedera has a JSON represented transaction fee ([9](https://docs.hedera.com/guides/docs/hedera-api/basic-types/feedata)). This includes a list of accounts that are part of each transaction. By enabling the ability for new HTS based tokens to optionally append a few custom entities and associated payments to this list dramatically expand the functionality and programmability available natively on Hedera.

## Specification
At the top level, we propose adding the following: 

```
CustomFee Class:
	- safePercentage percentageOfFee
	- AccountID treasuryId

HederaToken:
	- customFees[] customFees
	- getCustomFees()
	
HederaTokenTransfer(tokenId, amount, toAddress):
	customFees = tokenId.getCustomFees()
	remainingPercent = 1
	
	for customFee in customFees:
		tokenTransfer(tokenId, amount*customFee.percentageOfFee, customFee.treasuryId)
		remainingPercent -= customFee.percentageOfFee
	
	tokenTransfer(tokenId, amount*remainingPercent, toAddress)

TokenUpdateTransaction:
	- addCustomFee()
	
TokenInfo:
	- call getCustomFee()
```

Note: see the reference implementation section for more details.

## Backwards Compatibility
There are no known backwards compatibility issues. All tokens defined on HTS at the time of this implementation could retain their current transaction record structure and be processed by the network, mirror nodes, etc. as if they were tokens created without custom token fee schedules. 

For future compatibility with this issue there are changes that will be required to the Hedera Mirror Nodes, on and off ramps, SDKs, wallets, and applications that are looking to support HTS assets with custom token fees.

## Security Implications 
This shouldn’t necessarily change security implications not already known by Hedera’s current fee model and transaction record structure/implementation. 

However, there is a potential additional DDoS vector which can and should be addressed with limitations to the number of custom fees per token issued on HTS, as well as additional HBAR related fees for token transactions requiring a custom defined token fee schedule, and associated more computationally expensive operations. 


## How to teach this
The most easily accessible way to explain this to users and developers in the ecosystem is that “just like HBAR is a required transaction fee to use the Hedera network, other tokens can be required to be used for additional custom fees in relation to other tokens.”

So similarly to how users might currently experience an insufficient transaction fee, like  “insufficient transaction fee: 0.05”  which we can deduce is related to HBAR, after the implementation of this HIP they may need to note “insufficient transaction fee: 0.05 {HBAR, or token name}” depending on the configuration of the token being transferred.

## Reference implementation

Current transaction record:
```
{
  "signatures": [],
  "transactionID": {
    "accountID": {
      "num": 40938,
      "shardNum": 0,
      "realmNum": 0
    },
    "validStartDate": "2021-05-04T14:08:51.927014828Z"
  },
  "nodeAccountID": {
    "num": 11,
    "shardNum": 0,
    "realmNum": 0
  },
  "transactionFee": 1000000000,
  "transactionValidDurationInSec": 120,
  "generateRecord": false,
  "memo": "",
  "fileName": "recordstreams/record0.0.6/2021-05-04T14_09_00.011224000Z.rcd",
  "index": 388,
  "record": {
    "transactionHash": "acacc3ceb6f71171f80cc5fefbdb2b6355a1fe90e06194091851523f996e8b0ae1b35ad586440105e0aecaeb8bcab681",
    "consensusTimeStamp": "2021-05-04T14:09:01.674103Z",
    "transactionFee": 310019,
    "transactionID": {
      "accountID": {
        "num": 40938,
        "shardNum": 0,
        "realmNum": 0
      },
      "validStartDate": "2021-05-04T14:08:51.927014828Z"
    },
    "memo": "",
    "transfers": [
      {
        "accountID": {
          "num": 11,
          "shardNum": 0,
          "realmNum": 0
        },
        "amount": 21801
      },
      {
        "accountID": {
          "num": 98,
          "shardNum": 0,
          "realmNum": 0
        },
        "amount": 288218
      },
      {
        "accountID": {
          "num": 40938,
          "shardNum": 0,
          "realmNum": 0
        },
        "amount": -310019
      }
    ],
    "tokenTransfers": [
      {
        "tokenID": {
          "num": 127877,
          "shardNum": 0,
          "realmNum": 0
        },
        "accountAmount": [
          {
            "accountID": {
              "num": 40938,
              "shardNum": 0,
              "realmNum": 0
            },
            "amount": -10000000000
          },
          {
            "accountID": {
              "num": 54429,
              "shardNum": 0,
              "realmNum": 0
            },
            "amount": 10000000000
          }
        ]
      }
    ],
    "receipt": {
      "responseCode": "SUCCESS",
      "currentExchangeRate": {
        "hBarEquiv": 30000,
        "centEquiv": 923617,
        "expirationTime": "2021-05-04T15:00:00Z"
      },
      "nextExchangeRate": {
        "hBarEquiv": 30000,
        "centEquiv": 920642,
        "expirationTime": "2021-05-04T16:00:00Z"
      }
    }
  },
  "transfers": [],
  "transactionType": "CRYPTO_TRANSFER"
}
```

Example of a new transaction record:
```
{
  "signatures": [],
  "transactionID": {
    "accountID": {
      "num": 40938,
      "shardNum": 0,
      "realmNum": 0
    },
    "validStartDate": "2021-05-04T14:08:51.927014828Z"
  },
  "nodeAccountID": {
    "num": 11,
    "shardNum": 0,
    "realmNum": 0
  },
  "transactionFee": 1000000000,
  "customTokenFees": [
      {
        "tokenID": {
          "num": 127877,
          "shardNum": 0,
          "realmNum": 0
        },
        "accountAmount": [
          {
            "accountID": {
              "num": 40938,
              "shardNum": 0,
              "realmNum": 0
            },
            "amount": -10000000000
          },
          {
            "accountID": {
              "num": 54429,
              "shardNum": 0,
              "realmNum": 0
            },
            "amount": 10000000000
          }
        ]
      }
  ],
  "transactionValidDurationInSec": 120,
  "generateRecord": false,
  "memo": "",
  "fileName": "recordstreams/record0.0.6/2021-05-04T14_09_00.011224000Z.rcd",
  "index": 388,
  "record": {
    "transactionHash": "acacc3ceb6f71171f80cc5fefbdb2b6355a1fe90e06194091851523f996e8b0ae1b35ad586440105e0aecaeb8bcab681",
    "consensusTimeStamp": "2021-05-04T14:09:01.674103Z",
    "transactionFee": 310019,
    "transactionID": {
      "accountID": {
        "num": 40938,
        "shardNum": 0,
        "realmNum": 0
      },
      "validStartDate": "2021-05-04T14:08:51.927014828Z"
    },
    "memo": "",
    "transfers": [
      {
        "accountID": {
          "num": 11,
          "shardNum": 0,
          "realmNum": 0
        },
        "amount": 21801
      },
      {
        "accountID": {
          "num": 98,
          "shardNum": 0,
          "realmNum": 0
        },
        "amount": 288218
      },
      {
        "accountID": {
          "num": 40938,
          "shardNum": 0,
          "realmNum": 0
        },
        "amount": -310019
      }
    ],
    "tokenTransfers": [
      {
        "tokenID": {
          "num": 127877,
          "shardNum": 0,
          "realmNum": 0
        },
        "accountAmount": [
          {
            "accountID": {
              "num": 40938,
              "shardNum": 0,
              "realmNum": 0
            },
            "amount": -10000000000
          },
          {
            "accountID": {
              "num": 54429,
              "shardNum": 0,
              "realmNum": 0
            },
            "amount": 10000000000
          }
        ]
      }
    ],
    "receipt": {
      "responseCode": "SUCCESS",
      "currentExchangeRate": {
        "hBarEquiv": 30000,
        "centEquiv": 923617,
        "expirationTime": "2021-05-04T15:00:00Z"
      },
      "nextExchangeRate": {
        "hBarEquiv": 30000,
        "centEquiv": 920642,
        "expirationTime": "2021-05-04T16:00:00Z"
      }
    }
  },
  "transfers": [],
  "transactionType": "CRYPTO_TRANSFER"
}
```

## Additional examples 
```
new TokenCreateTransaction()
	.setName(..)
	.setCustomFee({token-id}}, {value}, {account-id})
	.setCustomFee(0.0.987, 100, 0.0.123)
	...
	.execute(client)
```	

In this example, the token created would require 100 tokens with entity ID 0.0.987 to be transferred into the account with entity ID 0.0.123. Account 0.0.123 could obviously be a single individual’s account, or it could be a multisignature account managed by an HCS based validator network, as we’ve recently seen in Greg Scullard’s NFT auction demo ([10](https://www.youtube.com/watch?v=hCPXKR1e7Ro)).

This could be expanded to include multiple custom fees per token, up to the 6kb transaction limit imposed by the Hedera network as it currently stands ([11](https://docs.hedera.com/guides/docs/hedera-api/consensus-service/consensussubmitmessage#consensussubmitmessagetransactionbody)), or another threshold determined to help reduce the potential of a DDoS attack on the network through bloated custom token fee schedules.

```
new TokenCreateTransaction()
	.setName(..)
	.setCustomFee(0.0.987, 100, 0.0.123)
	.setCustomFee(0.0.987, 200, 0.0.456)
	.setCustomFee(HBAR, 10, 0.0.753)
	...
	.execute(client)
```	

An obvious example for this is a multiparty ecosystem, with a community managed treasury, a foundation treasury, and the genesis application. Or in the meta-example, Hedera having distinct buckets for each the node, service, and network fees respectively which could trustlessly be managed by different entities, like a DAO.

We also propose adding the following percentage based variation of the base implementation. 

```
new TokenCreateTransaction()
	.setName(..)
	.setCustomFeePercentage({token-id}}, {value}, {account-id})
	.setCustomFeePercentage(0.0.987, 10%, 0.0.123)
	...
	.execute(client)
```

Typically, percentage royalties will be deducted from the tokens being transferred. If there are no tokens being transferred, then when tokens are created there can be a “minimum” or fallback price denominated in any token. In the example below 10 tokens with entity ID 0.0.987 would be required to be sent to account 0.0.123 in the case there was a 0 value transaction, or anything that would result in a royalty percentage fee less than the minimum. 

```
new TokenCreateTransaction()
	.setName(..)
	.setCustomFeePercentage({token-id}}, {value}, {account-id})
	.setCustomFeePercentage(0.0.987, 10%, 0.0.123)
	.setMinimumCustomFeeValue({token-id}, {value}, {account-id})
	.setMinimumCustomFeeValue(0.0.987, 10, 0.0.123)
	...
	.execute(client)
```

If the token relationship or fee ID is defined as empty, or null, then the custom fee is applied to the token that is being created (because there isn’t yet an entity ID by which we can refer to it). If there are not enough tokens, or those tokens are not sufficiently divisible, then an error for “insufficient custom token transaction fee” (or something similar) would be thrown. It would be on the user transacting to go out and accumulate enough tokens in their wallet to successfully execute the transaction with the defined custom token fee schedules. 

```
new TokenCreateTransaction()
	.setName(..)
	.setCustomFeePercentage({token-id}}, {value}, {account-id})
	.setCustomFeePercentage(null, 10%, 0.0.123)
	...
	.execute(client)
```

## Use cases 
Currently on Hedera, there is no decentralized and trustless mechanism of distributing the value that is captured when a token transfer occurs. At least, not natively at Layer 1. If issuing an NFT, for a single example, a user could simply transact that token peer-to-peer via a wallet that supports HTS and circumvent any potential fees that are implemented at the application layer, removing the trustless value proposition that new asset classes like NFTs enable for their creators. This prposal allows this use case to be easily addressed, among a large variety of others.

Other general/categorical examples include:

- Multiparty / multi stakeholder ecosystem treasuries
- Liquidity provisioning 
- Automated community incentives 
- Native protocol tokens being built upon Hedera, e.g. those used in many 3rd party apps
- Trustless perpetual royalties, e.g. NFTs
