---
hip: 1069
title: Enable KeyList Support in HTS Token Creation and Update Operations
author: Michael Garber <@michael.garber>
working-group: Giuseppe Bertone <@giuseppebertone>, Nikolaos Kamarinakis <@nikolaoskamarinakis>
requested-by: Axelar
type: Standards Track
category: Service
needs-council-approval: Yes
status: Draft
created: 2024-10-31
discussions-to: https://github.com/hashgraph/hedera-improvement-proposal/discussions/1069
updated: 2024-10-31
---

## Abstract
This HIP proposes an enhancement to the Hedera Token Service (HTS) precompile functions to support **KeyLists** in both token creation and key updates. Although KeyLists are supported within the SDK, they cannot currently be set through the HTS precompiles, which limits their usability in smart contracts for token management. Enabling KeyList support within the HTS precompiles would allow token keys managed by KeyLists to be set during creation and updated on-chain, adding significant flexibility for contract-based token operations.

## Motivation
The Hedera SDK allows setting KeyLists for token keys, which is a useful feature for multi-signature setups and threshold-based authorizations. However, the HTS precompile functions do not currently support KeyLists, making it impossible to create or update token keys with multiple signatories directly on-chain. This limitation creates a gap in functionality, especially for projects that rely heavily on multi-signature control within contract environments, such as Axelar's cross-chain integrations.

## Rationale
Supporting KeyLists directly within the token creation and update precompiles aligns with Hedera's goal of providing flexible, decentralized token management. By allowing contract-based applications to set KeyLists during token creation and subsequent updates, developers can enhance security and improve token access controls within contract-managed tokens, without needing to rely on external SDK calls or workarounds.

## User Stories
1. **As a developer** managing a cross-chain bridge, I want to create tokens with KeyLists and update token keys through HTS precompiles, allowing multiple signatories to authorize operations.
2. **As a DApp creator**, I want to create tokens with a `KeyList` as the supply key and update it as needed, using a threshold mechanism to ensure decentralized control over supply adjustments.
3. **As a DAO member**, I want to both create and update token keys on-chain using a `KeyList` to allow multi-signature voting for key management.
4. **As a protocol developer**, I want to initialize tokens with KeyLists during creation to establish proper governance controls from the start.

## Specification
The following updates are proposed to the HTS precompile functions:

### Updated Token Creation Function
Add support for `KeyList` types within the token creation parameters:

```solidity
    /// Operation to create a token with KeyList support
    /// @param token The token creation parameters, including KeyLists for multi-key support
    /// @return responseCode The response code for the status of the request. SUCCESS is 22.
    /// @return tokenAddress The created token's address
    function createToken(
        IHederaTokenService.HederaToken memory token
    ) internal returns (int64 responseCode, address tokenAddress) {
        (bool success, bytes memory result) = precompileAddress.call(
            abi.encodeWithSelector(
                IHederaTokenService.createToken.selector,
                token
            )
        );
        (responseCode, tokenAddress) = success
            ? abi.decode(result, (int32, address))
            : (HederaResponseCodes.UNKNOWN, address(0));
    }
```

### Updated `updateTokenKeys` Precompile Function
Add support for `KeyList` types within `IHederaTokenService.TokenKey[]` in the `updateTokenKeys` function:

```solidity
    /// Operation to update token keys with KeyList support
    /// @param token The token address
    /// @param keys The token keys, including KeyLists for multi-key support
    /// @return responseCode The response code for the status of the request. SUCCESS is 22.
    function updateTokenKeys(
        address token,
        IHederaTokenService.TokenKey[] memory keys
    ) internal returns (int64 responseCode) {
        (bool success, bytes memory result) = precompileAddress.call(
            abi.encodeWithSelector(
                IHederaTokenService.updateTokenKeys.selector,
                token,
                keys
            )
        );
        (responseCode) = success
            ? abi.decode(result, (int32))
            : HederaResponseCodes.UNKNOWN;
    }
```

Example Usage for both operations:

```solidity
    // KeyList definition
    IHederaTokenService.TokenKey memory key = IHederaTokenService.TokenKey({
        keyType: KeyType.SUPPLY,
        key: KeyList({
            keys: [
                Key(KeyType.ECDSA_SECP256K1, ecdsaPublicKey1),
                Key(KeyType.CONTRACT_ID, contractId2)
            ],
            threshold: 2
        })
    });

    // Creation with KeyList
    IHederaTokenService.HederaToken memory tokenParams = IHederaTokenService.HederaToken({
        name: "Example Token",
        symbol: "EXT",
        treasury: msg.sender,
        keys: [key],
        // ... other parameters
    });

    (int responseCode, address tokenAddress) = IHederaTokenService.createToken(tokenParams);

    // Updating with KeyList
    IHederaTokenService.updateTokenKeys(tokenAddress, [key]);
```

## Backwards Compatibility
No foreseen issues

## Security Implications
TBD

## How to Teach This
This enhancement should be documented in the Hedera developer documentation, with examples on how to set KeyLists for token keys during both creation and updates using the HTS precompiles.

## Reference Implementation
A reference implementation should mirror the specification given within the Hedera SDK to allow developers to use KeyLists within HTS precompiles for both token creation and updates, ensuring compatibility with both contract-based and SDK token operations.

## Rejected Ideas
External SDK Workarounds: Using SDK calls outside of the smart contract was considered but found impractical for fully on-chain applications.

## Open Issues
1. 
2.