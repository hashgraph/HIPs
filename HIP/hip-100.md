---
hip: 100
title: Signature and Wallet Providers
author: Daniel Akhteorv <daniel@launchbadge.com>
type: Standards Track
category: Application
needs-council-approval: Yes
status: Draft
created: 2022-01-20
discussions-to: TBD
updated: 2022-01-20
---

## **Abstract**

Ethereum like signature and wallet providers with the Hedera SDKs

## **Motivation**

Cryptocurrency users are more used to Ethereum's signature and wallet providers instead
of direclty hardcoding private keys into their projects. Supporting third party signature
and wallet provider would be better for security and user experience.

## **Specification**

<details>
<summary>abstract class Signer</summary>
  
### Methods

##### `async signMessage` ( `messages`: `List` < `bytes` > ): `List` < `List` < `SignerSignature` > >

Sign a list of messages

**NOTE**: Each element in the outer list of the result is all the signatures for the
message at the same index.

---

##### `async signTransaction` ( `transaction`: `Transaction` )

Signs the transaction

**NOTE**: Use `Transaction.getSignatures()` to see the actual signatures.
at the same index.

---

##### `async sendTransaction` ( `transaction`: `Transaction` ): `TransactionReceipt`

Sign and send a transaction using the wallet

**NOTE**: Unlike `Provider.sendTransaction()` this method will automatically wait for
the receipt of the transaction.

---

##### `async checkTransaction` ( `transaction`: `Transaction` )

Determines if all the properties requried are set and sets the transaction ID. If the transaction ID was already set it checks if the account ID of it is the same as the users.

---

##### `async populateTransaction` ( `transaction`: `Transaction` )

Sets the transaction ID of the transaction to the current account ID of the signer.

---

##### `getLedgerId` (): `LedgerId`

Return the ledger ID

---

##### `getAccountId` (): `AccountID`

Return the account ID associated with this signer

---

##### `async getAccountBalance` (): `AccountBalance`

Fetch the account's balance

---

##### `async getAccountInfo` (): `AccountInfo`

Fetch the account's info

---

##### `async getTransactionRecords` (): `List` < `TransactionRecord` >

Fetch the last transaction records for this account using `TransactionRecordQuery`

---

##### `async getTransactionRecords` (): `List` < `TransactionRecord` >

Fetch the last transaction records for this account using `TransactionRecordQuery`

---
</details>

<details>
<summary>abstract class Provider</summary>

> abstract class `Provider`

### Methods

##### `getLedgerId` (): `LedgerId`

Return the ID of the current network

---

##### `async getAccountBalance` ( `accountId`: `AccountId` ): `AccountBalance`

Get the balance for an account

---

##### `async getAccountInfo` ( `accountId`: `AccountId` ): `AccountInfo`

Get the info for an account

---

##### `async getTransactionReceipt` ( `transactionId`: `TransactionId` ): `TransacitonReceipt`

Get a receipt for a transaction ID

---

##### `async sendTransaction` ( `transaction`: `Transaction` ): `TransactionResponse`

Sign and send a transaction using the wallet

---

##### `async waitForReceipt` ( `response`: `TransactionResponse` ): `TransactionReceipt`

Wait for the receipt for a transaction response

**NOTE**: This is different than `getTransactionReceipt()` this method requires a `nodeId` which
is set inside `TransactionResponse` and as a result should not be able to fail with `RECEIPT_NOT_FOUND`

---
</details>

<details>
<summary>abstract class Wallet extends Signer</summary>

### Static Methods

##### `withPrivateKey` ( `privateKey`: `PrivateKey` ): `Wallet`

Create a wallet using a private key

---

### Methods

##### `getProvider` (): `Provider`

Return the provider

---

##### `getPublicKey` (): `PublicKey`

Return the public key associated with this wallet.

---

##### `async createRandomED25519` (): `Wallet`

Creates a wallet with a new ED25519 key

**NOTE**: This would create an alias key account on Hedera

---

##### `async createRandomECDSA` (): `Wallet`

Creates a wallet with a new ECDSA key

**NOTE**: This would create an alias key account on Hedera

---
</details>

<details>
<summary>class SignerSignature</summary>

### Fields

##### `publicKey`: `PublicKey`

The public key that signed this request

##### `signature`: `bytes`

The siganture for the message

</details>

<details>
<summary>class LocalWallet implements Wallet</summary>

### Static Methods

### Constructor

##### `constructor`()

Creates an `LocalWallet` from the environment variables `OPERATOR_KEY`, `OPERATOR_ID`, and `HEDERA_NEWTORK`

---

### Methods

##### async `sign` ( `messages`: `List` < `bytes` > ): `List` < `List` < `SignatureProviderSignature` > >

Signs all the messages with all the private keys.

---
</details>

<details>
<summary>class VoidSigner extends Signer</summary>

### Static Methods

##### `withAccountId` ( `accountId`: `AccountId` ): `VoidSigner`

Create a wallet using a private key

---

### Methods

##### `getProvider` (): `Provider`

Return the provider

---

##### `getPublicKey` (): `PublicKey`

Will return `null`

---

##### `async signTransaction` ( `transaction`: `Transaction` )

Will do nothing

---

##### `async sendTransaction` ( `transaction`: `Transaction` ): `TransactionReceipt`

Will throw an error as sending a transaction using a `VoidSigner` is not supported.

---
</details>

#### Example RPCs

<details>

<summary>class GrpcSignatureProvider extends Provider</summary>

### Protobuf Defintions

```protobuf
syntax = "proto3";

/**
 * Strictlly declared to hopefully future proof
 */
message SignRequest {
    oneof versions {
        RequestSignatureV1 v1 = 1;
    }
}

/**
 * Strictlly declared to hopefully future proof
 */
message SignResponse {
    oneof versions {
        ResponseSignatureV1 v1 = 1;
    }
}

/**
 * A simple request to sign a message
 */
message RequestSignatureV1 {
    /**
     * Each message that needs to be signed
     */
    repeated bytes messages = 1;
}

/**
 * Strictlly declared to hopefully future proof
 */
message ResponseSignatureV1 {
    /**
     * Each key **MUST** be an SPKI DER encoded public key
     */
    repeated bytes public_keys = 1;

    /**
     * **MUST NOT** repeat the `Signature.public_key` multiple types otherwise the RPC will be
     * considered failed and all signatures disgarded.
     *
     * Each element in this list **MUST** match the signatures for the message at the same index.
     */
    repeated SignatureList signatures = 2;
}

/**
 * List of sigantures for a given messages
 */
message SignatureList {
    repeated Signature signatures = 1;
}

/**
 * The signature for particular message and public key
 *
 * **NOTE**: The reasoning for using indices is to shink the response size when
 * multiple keys and messages are used.
 */
message Signature {
    /**
     * The index of the public key in the response
     */
    uint32 public_key_index = 1;

    bytes signature = 2;
}

/**
 * The gRPC API for signing
 */
service GrpcSignatureProvider {
    rpc sign(SignRequest) returns (SignResponse);
}
```
</details>

<details>
<summary>class JsonRpcProvider extends Provider</summary>

JSON RPC Signature providers **MUST** implement [JSON RPC](https://www.jsonrpc.org/specification)

### JSON RPC Defintions

```typescript
interface SignMethodRequest {
    jsonrpc: "2.0",
    method: "sign",
    params: SignRequest,
}

interface SignMethodResponse {
    jsonrpc: "2.0",
    result?: SignResponse,
    error?: JsonRpcError,
    id: string | number | null;
}

interface JsonRpcError {
    code: number;
    message: string;
    data?: any;
}

/**
 * Strictlly declared to hopefully future proof
 */
type SignRequest = ResponseSignatureV1;

/**
 * Strictlly declared to hopefully future proof
 */
type SignResponse = ResponseSignatureV1;

/**
 * A simple request to sign a interface
 */
interface RequestSignatureV1 {
    /**
     * Each interface that needs to be signed
     */
    interfaces: Uint8Array[];
}

/**
 * Strictlly declared to hopefully future proof
 */
interface ResponseSignatureV1 {
    /**
     * Each key **MUST** be an SPKI DER encoded public key
     */
    publicKeys: Uint8Array[];

    /**
     * **MUST NOT** repeat the `Signature.publicKey` multiple types otherwise the RPC will be
     * considered failed and all signatures disgarded.
     *
     * Each element in this list **MUST** match the signatures for the public key at the same index.
     *
     * e.g. The signatures for the message at index 0 will be accessible 
     * `ResponseSignatureV1.signatures[0].signatures`
     */
    signatures: SignatureList[];
}

/**
 * List of sigantures for a given messages
 */
interface SignatureList {
    signatures: Signature[];
}

/**
 * The signature for particular interface and public key
 *
 * **NOTE**: The reasoning for using indices is to shink the response size when
 * multiple keys and interfaces are used.
 */
interface Signature {
    /**
     * The index of the public key in the response
     */
    publicKeyIndex: number;

    signature: Uint8Array;
}
```
</details>

## **Backwards Compatibility**

This is 100% backwards compatible

## **Security Implications**

WIP: [hethers.js](https://github.com/hashgraph/hethers.js/issues)

## **How to Teach This**

N/A

## **Reference Implementation**

N/A

## **Rejected Ideas**

N/A

## **Open Issues**

N/A

## **References**

## **Copyright/license**

This document is licensed under the Apache License, Version 2.0 -- see [LICENSE](https://github.com/hashgraph/hedera-improvement-proposal/LICENSE) or ([https://www.apache.org/licenses/LICENSE-2.0](https://www.apache.org/licenses/LICENSE-2.0))