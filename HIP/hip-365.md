---
hip: 365
title: Partially Fungible Tokens
author: Albert Tam <albert.tam@hedera.com>
working-group: John Shipman <jshipman@centre.io>, Chad Richman <crichman@centre.io>, Atul Mahamuni <atulmahamuni@hedera.com>, Mohsin Qamar <mohsin.qamar@hedera.com>
type: Standards Track
category: Service
needs-council-approval: Yes
status: Draft
created: 2022-02-10
discussions-to: https://github.com/hashgraph/hedera-improvement-proposal/discussions/384
updated: 2022-03-06
---

## Abstract

This proposal describes a feature that allows institutions to manage a token that is partially fungible with other related tokens. The fungibility of the tokens is determined by a transfer policy that is comprised of triggered smart contracts that decide the transfer outcome and are capable of re-calculating the transfer list.

## Motivation

The current `TokenService` feature set does not provide enough flexibility to implement a multi-issuer network where each of those token "flavors" are fully fungible and able to be exchanged without the use of smart contracts to burn and mint. Brokering different tokens via a smart contract is also not ideal when high transaction rates (that is, close to 10K tps) are required.

The ideal solution will allow for multi-issuer fungibility and trigger alternative logic based upon the type of tokens involved in the transfer. Complex transfer scenarios such as discounts, chargebacks and loyalty/reward grants should also be supported, although these paths are exception cases and can be implemented within the smart contract layer.

## User stories

As a token issuer, I want to mint and manage my own token and have this token be fungible with tokens issed by other issuers in my consortium.

As a token issuer, I want to attach tags or alternative identifiers to the token to distinguish if from other tokens that it is fungible with.

As a token issuer, I want the transfer of tokens to conditionally trigger a smart contract execution based upon the properties of the token such as its tags or the transfer amount.

As a token issuer, I want the transfer logic triggers to NOT be smart contract based in order to utilize the full speed of token transfers.

As a token issuer, I want the triggered smart contract to be able to approve or deny the transfer. 

As a token issuer, I want the triggered smart contract to be able to modify the transfer list to allow for custom discounts.

As a token issuer, I want the triggered smart contract to be able to modify the transfer list to allow for other tokens (such as reward tokens) to be granted to transfer parties.

As a token user, I want to be able to identify the number of partially fungible tokens in my account that were issued by each issuer.

## Specification

### Terminology

The following terms will be used repeatedly throughout this section:

- root token: the token containing the transfer policy.
- sub-token: a token associated with the root token that contains a set of tags.
- transfer policy: a series of rules that govern transferability of the root token and any constituent sub-tokens.
- transfer rule: combination of a trigger expression and a smart contract address that will be executed if the expression evaluates to true.
- family - a root token plus all of the sub-tokens that are associated with it.

### Introduction of Root Token Type

The main component of the partially fungible token family is the root token. This token serves as the repository for the transfer policy that will be applied during transfer of the root and sub-tokens.

In an object-oriented sense, the root token can be thought of as an abstract base class while the sub-tokens are derived concrete classes. The root token itself cannot be minted, but any transfers of the associated sub-tokens can use the `TokenID` of the root token and allow the transfer policy to determine the actual concrete sub-tokens to use instead.

One example of how a root token and sub-tokens can be used is the case of a stablecoin that is issued by multiple providers. Each of the providers would like to identify their coins with a series of markers or tags. Users of the stablecoin may perform transfers using the tagged variants or they may want to perform the exchange using the root token instead and allow a contract to determine what the variant(s) should be.

The exising `TokenCreate` Hedera API will be extended to handle the creation of a root token.

```protobuf
enum TokenType {
	// existing values
	FUNGIBLE_COMMON = 0;
	NON_FUNGIBLE_UNIQUE = 1;
	
	// new values
	FUNGIBLE_PARTIAL_ABSTRACT = 2;
	FUNGIBLE_PARTIAL_DERIVED = 3;
}

// existing message
message TokenCreateTransactionBody {
	// existing fields
	string name = 1;
	string symbol = 2;
	uint32 decimals = 3;    // must be 0
	uint64 initialSupply = 4;    // must be 0
	AccountID treasury = 5;    // not used
	Key adminKey = 6;
	Key kycKey = 7;
	Key freezeKey = 8;    // not used
	Key wipeKey = 9;    // not used
	Key supplyKey = 10;    // not used
	bool freezeDefault = 11;    // must be false
	Timestamp expiry = 13;
	AccountID autoRenewAccount = 14;
	Duration autoRenewPeriod = 15;
	string memo = 16;
	TokenType tokenType = 17;    // FUNGIBLE_PARTIAL_ABSTRACT
	TokenSupplyType supplyType = 18;    // FINITE
	int64 maxSupply = 19;    // must be 0
	Key fee_schedule_key = 20;    // not used
	repeated CustomFee custom_fees = 21;    // not used
	Key pause_key = 22;
	
	// new field for root tokens
	repeated PolicyRule transfer_policy = 23;
	ContractID default_sub_token_assignment = 24;
	Key sub_token_key = 25;
	
	// new field for sub-tokens
	TokenID root_token_id = 26;
	repeated string tags = 27;
}
```

Two new `TokenType` enumeration values will be introduced to denote the root and sub-token types:

- `FUNGIBLE_PARTIAL_ABSTRACT` - root token
- `FUNGIBLE_PARTIAL_DERIVED` - sub-token

A majority of the fields in the `TokenCreateTransactionBody` message are not required for root token creation as there is no supply to manage. The following fields will be ignored if specified in any `TokenCreate` for a root token:

- `decimals` will use value 0 instead
- `initialSupply` will use value 0 instead
- `treasury`
- `freezeKey`
- `wipeKey`
- `supplyKey`
- `freezeDefault` will use value `false` instead
- `supplyType` will use value `FINITE` instead
- `maxSupply` will use value 0 instead
- `fee_schedule_key`
- `custom_fees`
- `root_token_id`
- `tags`

The transfer policy is optional and need not exist for a root token.

The optional `default_sub_token_assignment` field specifies the contract to invoke if the transfer list still contains a reference to the root token after all of the policy rules have been evaluated. Details on the purpose of the contract can be found in the [default sub-token assignment contract](#default-sub-token) section.

The optional `sub_token_key` field specifies the key that permits a new sub-token to be associated with the root token. This key is used when the root token owner wants to control which sub-tokens to add to the family. If the field is not empty, all sub-token `TokenCreate` operations wishing to be associated with the root token must be signed by the `sub_token_key`. If the field is empty then any sub-token can derive itself from the root token without restriction.

The root token cannot be associated with an account as this token type cannot be minted. Any `TokenAssociate` transactions involving a root token will fail.

The root token will be subject to auto renewal fees. Even though the root token does not maintain a supply, configuration storage is still required.

#### Transfer Policy

The transfer policy consists of a series of rules, each of which are executed during a token transfer of either the root or associated sub-tokens.

Each of the rules consists of two parts:

1. A trigger boolean expression that will always be evaluated during a transfer.
2. The address of a previously deployed smart contract that will be executed if the trigger expression evaluates to true.

The trigger boolean expression is specified using the following protobuf messages.

```protobuf
message TriggerExpression {
	oneof expr {
		AndExpression and_expr = 1;
		OrExpression or_expr = 2;
		NotExpression not_expr = 3;
		FunctionExpression fx_expr = 4;
		google.protobuf.BoolValue bool_expr = 5;
	}
}

message AndExpression {
	TriggerExpression left_expr = 1;
	TriggerExpression right_expr = 2;
}

message OrExpression {
	TriggerExpression left_expr = 1;
	TriggerExpression right_expr = 2;
}

message NotExpression {
	TriggerExpression expr = 1;
}

message FunctionExpression {
	oneof fx {
		HasSubTokenFunction has_sub_token_fx = 1;
		HasTagFunction has_tag_fx = 2;
		HasTagsFunction has_tags_fx = 3;
		HasNoTagsFunction has_no_tags_fx = 4;
	}
}

message HasSubTokenFunction {
	TokenID token_id = 1;
}

message HasTagFunction {
	string tag = 2;
}

message HasTagsFunction {
	repeated string tags = 1;
}

message HasNoTagsFunction {
}

message PolicyRule {
	TriggerExpression trigger = 1;
	ContractID contract_id = 2;
}
```

Each of the rules are executed in the order they are defined. This means that it is possible for the trigger expression of one rule to be affected by the execution of an earlier triggered smart contract that altered the transfer list.

No gas is required to execute the policy rule triggers. Payment for trigger execution will be covered by hbar transaction fees.

The gas to use for all of the policy rule contracts executed will be specified as part of the transfer transaction. Each of the executed contracts will deduct the exact amount used. If there is any gas remaining after the last policy rule contract has executed, the remainder will be refunded up to current maximum refund percentage set for the network. Note that if the [default sub-token assignment contract](#default-sub-token) must be invoked, the gas refund will occur **after** that contract has finished execution.

If an insufficient gas condition is reached during any contract call, the transaction will fail with `INSUFFICIENT_GAS`.

If none of the policy rule triggers evaluate to true (meaning no smart contracts are invoked), none of the gas specified in the `PolicyRule` message will be used.

The maximum number of predicates permitted in a trigger expression is 10.

##### Trigger Expression Functions

| Function    | Parameters | Description |
| :---        | :----      | :---        |
| HasSubToken  | token_id   | Returns `true` if any of the transfers involves the a sub-token with the specified `token_id`. |
| HasTag      | tag        | Returns `true` if any of the transfers involves a sub-token with the specified `tag`. |
| HasTags     | tags       | Returns `true` if any of the transfers involves a sub-token with all of the specified `tags`. |
| HasNoTags   |            | Returns `true` if all of the transfers involve the root token. |

##### <a name="smart-contract-invocation"></a>Smart Contract Invocation

Smart contracts associated with a policy rule must implement the `ITransferHandler` Solidity interface. 

```solidity
interface ITransferHandler {
	function handleTransaction(TransferTransaction tx) external returns TransferTransaction;
}
```

When a rule trigger evaluates to `true`, the contract located at the associated address will be executed with the `TransferTransaction` parameter. The `CryptoTransfer` transaction does not permit for any other user-specified parameters to be passed in.

The `TransferTransaction` and related Solidity structs will be made available publically for import for contract development.

```solidity
struct TransferTransaction {
	TransferList transfers;
	TokenTransferList[] tokenTransfers;
}

struct TransferList {
	AccountAmount[] accountAmounts;
	bool isValid;
}

struct AccountAmount {
	AccountID accountID;
	int64 amount;
	bool isApproval;
}

struct TokenTransferList {
	TokenID token;
	AccountAmount[] transfers;
	NftTransfer nftTransfers;
	uint32 expectedDecimals;
	bool hasExpectedDecimals;
}

struct NftTransfer {
	AccountID senderAccountID;
	AccountID receiverAccountID;
	int64 serialNumber;
	bool isApproval;
	bool isValid;
}

struct AccountID {
	uint64 shardNum;
	uint64 realmNum;
	uint64 accountNum;
	bytes alias;
}

struct TokenID {
	uint64 shardNum;
	uint64 realmNum;
	uint64 tokenNum;
}
```

The contract can deny the transfer by calling one of `revert`, `require` or `assert`.

The contract can modify the transfer list to implement any number of complex discount or chargeback scenarios. The modified transfer list should be returned from the `handleTransaction` function. If no modifications are made to the transfer list the calldata `TransferTransaction` should be returned as the response value will be used as the definitive transfer list to execute.

### Introduction of Sub-Token Type

The sub-token constitutes the main transferable component in the partially fungible token family. It is created in a similar manner to regular fungible tokens in that it can be minted, burned, frozen, transferred, etc... Each sub-token contains a series of custom tags that help to distinguish the sub-token from other sub-tokens in the same family.

```protobuf
// existing message
message TokenCreateTransactionBody {
	// existing fields
	string name = 1;
	string symbol = 2;
	uint32 decimals = 3;    // must be 0
	uint64 initialSupply = 4;    // must be 0
	AccountID treasury = 5;    // not used
	Key adminKey = 6;
	Key kycKey = 7;
	Key freezeKey = 8;    // not used
	Key wipeKey = 9;    // not used
	Key supplyKey = 10;    // not used
	bool freezeDefault = 11;    // must be false
	Timestamp expiry = 13;
	AccountID autoRenewAccount = 14;
	Duration autoRenewPeriod = 15;
	string memo = 16;
	TokenType tokenType = 17;    // FUNGIBLE_PARTIAL_ABSTRACT
	TokenSupplyType supplyType = 18;    // FINITE
	int64 maxSupply = 19;    // must be 0
	Key fee_schedule_key = 20;    // not used
	repeated CustomFee custom_fees = 21;    // not used
	Key pause_key = 22;

	// new field for root tokens
	repeated PolicyRule transfer_policy = 23;
	ContractID default_sub_token_assignment = 24;
	Key sub_token_key = 25;
	
	// new field for sub-tokens
	TokenID root_token_id = 26;
	repeated string tags = 27;
}
```

Each sub-token is managed separately from other sub-tokens in the same family. There is no over-arching aggregate supply for all sub-tokens so each sub-token supply can be independently modified.

The `transfer_policy`, `default_sub_token_assignment` and `sub_token_key` fields are not relevant for sub-tokens and will be ignored if a value is given.

The `root_token_id` field is required and must refer to an existing root token. The transaction will fail if the token reference is not a root token.

If the target root token has been configured with a `sub_token_key`, the `TokenCreate` message must be signed using this key for this transaction to succeed. If the target root token does not have a `sub_token_key` no signing is required to create the sub-token.

The optional `tags` field and its values must be unique (when sorted) across all other sub-tokens within the same family. Due to the uniqueness constraint, only one sub-token in the family is permitted to have no tags at any time. If a sub-token in the family already has no tags, a `TokenCreate` with no tags or a `TokenUpdate` that removes tags will cause the transaction to fail.

As with other tokens, a user must be associated with the sub-token prior to a transfer or they must have a free auto-association slot in their account.

The sub-token is subject to auto renewal fees just like other fungible tokens.

### CRUD Operations

#### Update

The existing `TokenUpdate` Hedera API will be used to modify a previously created root token or sub-token. The protobuf message `TokenUpdateTransactionBody` will be modified to include the following fields:

- `transfer_policy` (for root tokens)
- `default_sub_token_assignment` (for root tokens)
- `sub_token_key` (for root tokens)
- `tags` (for sub-tokens)

```protobuf
// existing message
message TokenUpdateTransactionBody {
	// existing fields
	TokenID token = 1;
	string symbol = 2;
	string name = 3;
	AccountID treasury = 4;
	Key adminKey = 5;
	Key kycKey = 6;
	Key freezeKey = 7;
	Key wipeKey = 8;
	Key supplyKey = 9;
	AccountID autoRenewAccount = 10;
	Duration autoRenewPeriod = 11;
	Timestamp expiry = 12;
	google.protobuf.StringValue memo = 13;
	Key fee_schedule_key = 14;
	Key pause_key = 15;
	
	// new fields for root tokens
	repeated PolicyRule transfer_policy = 16;
	ContractID default_sub_token_assignment = 17;
	Key sub_token_key = 18;
	
	// new field for sub-tokens
	repeated string tags = 19;
}
```

The `default_sub_token_assignment` field specifies the contract to invoke if the transfer list still contains a reference to the root token after all of the policy rules have been evaluated. More details on the execution of this contract can be found in the [default sub-token assignment contract](#default-sub-token) section.

The optional `sub_token_key` field specifies the key that permits a new sub-token to be associated with the root token. This key is used when the root token owner wants to control which sub-tokens to add to the family. If the token currently has a sub-token key, setting this field will update the key associated with the token. If the token currently does not have a sub-token key, the transaction will fail with `TOKEN_HAS_NO_SUB_TOKEN_KEY`.

If the transaction is updating a sub-token and the fields `transfer_policy`, `default_sub_token_assignment` or `sub_token_key ` are not empty, the values will be ignored. These fields are only relevant for root tokens.

If the transaction is updating a root token the `tags` field will be ignored.

If the transaction is updating a root token and any of the following fields are specified in the `TokenUpdateTransactionBody` message, they will be ignored:

- `treasury`
- `freezeKey`
- `wipeKey`
- `supplyKey`
- `fee_schedule_key`

If the transaction is updating a sub-token and the `tags` field is empty or its value is not unique (when sorted) across all other sub-tokens within the same family, the transaction will fail.

#### Delete

An existing root token or sub-token can be deleted using the `TokenDelete` Hedera API. The existing protobuf message `TokenDeleteTransactionBody` will be reused for the transaction.

```protobuf
// existing message
message TokenDeleteTransactionBody {
    TokenID token = 1;
}
```

This transaction will fail if the transaction is deleting a root token and there are sub-tokens in the family. In order to delete the root token, all of its associated sub-tokens must be deleted first.

#### Get Token Info

The existing `TokenGetInfo` query API will be used to return configuration data regarding a root token or sub-token. The existing protobuf message `TokenInfo` will be modified to include the following fields:

- `transfer_policy` (for root tokens)
- `default_sub_token_assignment` (for root tokens)
- `sub_token_key` (for root tokens)
- `tags` (for sub-tokens)
	
```protobuf
// existing message
message TokenInfo {
	// existing fields
	TokenID tokenId = 1;
	string name = 2;
	string symbol = 3;
	uint32 decimals = 4;
	uint64 totalSupply = 5;
	AccountID treasury = 6;
	Key adminKey = 7;
	Key kycKey = 8;
	Key freezeKey = 9;
	Key wipeKey = 10;
	Key supplyKey = 11;
	TokenFreezeStatus defaultFreezeStatus = 12;
	TokenKycStatus defaultKycStatus = 13;
	bool deleted = 14;
	AccountID autoRenewAccount = 15;
	Duration autoRenewPeriod = 16;
	Timestamp expiry = 17;
	string memo = 18;
	TokenType tokenType = 19;
	TokenSupplyType supplyType = 20;
	int64 maxSupply = 21;
	Key fee_schedule_key = 22;
	repeated CustomFee custom_fees = 23;
	Key pause_key = 24;
	TokenPauseStatus pause_status = 25;
	bytes ledger_id = 26;
	
	// new fields for root tokens
	repeated PolicyRule transfer_policy = 27;
	ContractID default_sub_token_assignment = 28;
	Key sub_token_key = 29;
	
	// new field for sub-tokens
	repeated string tags = 30;
}
```

When querying root tokens, the majority of the fields in the `TokenInfo` message will either be omitted or will contain the default empty value (that is, 0 or `false`). The affected/omitted fields are:

- `decimals` will have value 0
- `totalSupply` will have value 0
- `treasury`
- `freezeKey`
- `wipeKey`
- `supplyKey`
- `defaultFreezeStatus`
- `maxSupply` will have value 0
- `fee_schedule_key`
- `custom_fees`
- `root_token_id`
- `tags` (pertinent to sub-tokens)

When querying sub-tokens, the `transfer_policy`, `default_sub_token_assignment` and `sub_token_key` fields will be empty.

#### Get Token Balance

The existing `CryptoGetInfo` query API will be used to retrieve balances of sub-tokens held in an account. The details of each owned sub-token will be contained in a `TokenRelationship` message. No root tokens will be returned via this API as this token type can neither be minted nor owned.

```protobuf
// existing message
message TokenRelationship {
	TokenID tokenId = 1;
	string symbol = 2;
	uint64 balance = 3;
	TokenKycStatus kycStatus = 4;
	TokenFreezeStatus freezeStatus = 5;
	uint32 decimals = 6;
	bool automatic_association = 7;
}
```

#### Get Sub-Token Balances

A new Hedera query API will be added under the Token Service called `TokenGetAccountSubTokenBalances`. This function will return all of the sub-tokens associated with the specified root token within a given account.

```protobuf
// new message
message TokenGetAccountSubTokenBalancesQuery {
	/**
	 * Standard info sent from client to node, including the signed payment, and what kind of
	 * response is requested (cost, state proof, both, or neither)
	 */
   QueryHeader header = 1;

	/**
	 * The Account for which information is requested
	 */
	AccountID account_id = 2;
	
	/**
	 * The root token of the partially fungible token family.
	 */
    TokenID root_token_id = 3;
}

// new message
message TokenGetAccountSubTokenBalancesResponse {
	/**
	 * Standard response from node to client, including the requested fields: cost, or state proof,
	 * or both, or neither
	 */
	ResponseHeader header = 1;

    /**
     * List of sub-token balances contained within the account.
     */
	repeated TokenBalance token_balances = 2;
}

// existing message
message TokenBalance {
	TokenID tokenId = 1;
	uint64 balance = 2;
	uint32 decimals = 3;
}
```

The query will fail under the following circumstances:

- The `root_token_id` does not refer to a root token.
- The `account_id` does not exist.

### Change CryptoTransfer to Support Partially Fungible Token Transfers

The existing CryptoTransfer API will be used to support the transfer of root tokens or sub-tokens. The existing protobuf message for `CryptoTransfer` will be reused with one minor change to the `TokenTransferList` message - the addition of a `policy_rule_invocation` field to store parameters required for policy rule contract execution.

```protobuf
// existing protobuf
message CryptoTransferTransactionBody {
	TransferList transfers = 1;
	repeated TokenTransferList tokenTransfers = 2;
}

// existing message
message TokenTransferList {
	// existing fields
	TokenID token = 1;
	repeated AccountAmount transfers = 2;
	repeated NftTransfer nftTransfers = 3;
	google.protobuf.UInt32Value expected_decimals = 4;
	
	// new field
	PolicyRuleInvocation policy_rule_invocation = 5;
}

// new message
message PolicyRuleInvocation {
	int64 gas = 1;
}
```

The `PolicyRuleInvocation` message currently contains a single parameter - the contract gas to use for policy rule contracts. A new protobuf message is used instead of adding the gas value directly to `TokenTransferList` in case additional contract parameters are required in the future.

All transfers of root tokens and sub-tokens will cause the transfer policy specified on the root token to be executed. If a policy rule trigger evaluates to `true`, the associated smart contract will be executed with the gas specified in the `PolicyRuleInvocation` message being used for the contract call.

If the `TokenTransferList` references a root token in the `token` field, the root token must either be configured with a [default sub-token assignment contract](#default-sub-token) or possess a policy rule contract that will modify the transfer list to refer solely to sub-tokens. The transfer transaction will fail if any root tokens remain in the transfer list after the transfer policy and default assignment contract have finished execution.

Excluding the possible modification of the transfer list by policy rule contracts, transfers of sub-tokens will behave the same regular fungible tokens.

The transfer transaction will fail under the following circumstances:

- The `accountID` sending and receiving the token cannot be the same address.
- The recipient account does not have an association with the token yet.
	- If the recipient account has auto-association enabled, at least one open slot must be available for the transfer to succeed.
- The recipient account has `receiverSigRequired` enabled and the recipient has not signed the transaction.
- The sender account does not have `amount` of token available.
- The transfer `amount` plus custom fixed fees will exceed the total amount of token available.
- Either the sender or recipient accounts are frozen for the specified token.
- The specified `token` is paused.
- A policy rule contract has thrown an error thereby denying the transfer.
- Insufficient gas has been specified in the `PolicyRuleInvocation` message for all of the policy rule contracts that are called.
- A policy rule contract does not implement the `ITransferHandler` interface.
- The transfer list still contains a reference to the root token after the transfer policy and default assignment contract have finished execution.

#### <a name="default-sub-token"></a>Default Sub-Token Assignment Contract

Token transfers that specify the root token in the transfer list must be resolved to one of the sub-tokens that belong in the token family. This resolution step can be performed by one of the policy rule contracts that are invoked as part of the `CryptoTransfer` transaction. If a single root token reference remains in the transfer list after all policy rule contracts have finished execution, the contract specified by the `default_sub_token_assignment` field in the root token will be invoked to complete the resolution step.

The contract specified by the `default_sub_token_assignment` must implement the same `ITransferHandler` interface that all policy rule contracts do (details on this interface can be found in the [smart contract invocation](#smart-contract-invocation) section).

The `default_sub_token_assignment` contract can perform any number of assignments such as:

- Assign all to one sub-token
- Disperse across a number of sub-tokens
- Pick one of the sub-tokens currently held in the submitter's account to assign to (will require a precompile call to fetch the account balance)
- Deny the transfer by throwing an error

There must be sufficient gas remaining for the `default_sub_token_assignment` contract to execute otherwise the transaction will fail with `INSUFFICIENT_GAS`. If there is any gas remaining after the `default_sub_token_assignment` contract has finished execution, the remainder will be refunded up to current maximum refund percentage set for the network.

## Backwards Compatibility

The fields added to `TokenCreateTransactionBody`:

- `transfer_policy`
- `default_sub_token_assignment`
- `sub_token_key`
- `root_token_id` and
- `tags`

are not used for `FUNGIBLE_COMMON` or `NON_FUNGIBLE_UNIQUE` transactions. Those fields are pertinent for `FUNGIBLE_PARTIAL_ABSTRACT` and `FUNGIBLE_PARTIAL_DERIVED` token types only and will not conflict with non-partial fungible token transactions.
	
Similarly for `TokenUpdate`, the fields added to `TokenUpdateTransactionBody`:

- `transfer_policy`
- `default_sub_token_assignment`
- `sub_token_key` and
- `tags`

are only applicable to partially fungible token types and will not conflict with the other token types.

The `TokenGetInfo` query will return the same token information as before plus the newly added fields:

- `transfer_policy`
- `default_sub_token_assignment`
- `sub_token_key` and
-  `tags`

Clients that are not interested in the account's sub-tokens can safely ignore these fields. Sub-token information will be returned in a `TokenRelationship` message in a manner consistent with other tokens.

The new `TokenGetAccountSubTokenBalances` query only pertains to root tokens. Any attempt to call this query with a non-partially fungible token will result in an error. Hedera API clients that are not interacting with root tokens will not be utilizing this query.

## Security Implications

## Rejected Ideas

### Supporting All Tag Combinations on a Token

The initial proposal added a finite set of tags along with a series of transfer rules on the existing `FUNGIBLE_COMMON` token type supported by Hedera. The transfer rules would be guarded by a trigger expression to prevent unnecessary smart contract invocations. This approach is similar to the single-tag design proposed by ERC-1410. Potential storage problems arose when we needed to extend the number of tags allowed per token. If we did not limit the possible number of distinct values per tag "slot", the wallet object used to store the token tag combinations could grow to unacceptible limits (for instance, 3 slots each with n possible values would give n^3 combinations). The current design eliminates this possibility by requiring the user to explicitly specify the tags on a per token basis during minting and does not permit tags to shift during transfer (as ERC-1410 does).

Another simplifying change was to introduce the notion of an abstract token (currently called the root token) to serve as a common transfer path when parties did not know exactly the tagged token to use. The abstract notion also served as a convenient place to store the transfer policy rules to eliminate duplication across the various tagged tokens.

### Using Solidity for Rule Trigger Syntax

The initial proposal considered using a stripped-down Solidity based syntax for the rule trigger expression. The trigger syntax would support the following:

- Logical operators (&&, ||, !)
- Numerical relational operators (==, !=, <, <=, >, >=)
- Built-in helper functions (`hasTag`, `getSenderAmount`, etc...)
- Access to a transfer transaction struct

```solidity
(hasTag("visa") || hasTag("amex")) && getSenderAmount() > 100
```

The Solidity expression would be parsed and converted into stack-based instructions that would in turn be evaluated during a token transfer.

Two concerns arose during design discussions:

1. Basing the trigger syntax on Solidity would eventually lead to a slippery-slope sitation where we would be required to support a larger subset of the Solidity language.
2. We may need to check for injection attacks as the number of built-in functions increases and the complexity of the expression grows.

The decision was made to simplify the expression language and keep  the encoding format as protobuf messages. This approach allows us to avoid the temptation of supporting larger subsets of Solidity syntax and keeps the execution object model straight-forward with no compilation (or transcompilation) required.

## Open Issues

## References

- [ERC 1410 Proposal](https://github.com/ethereum/eips/issues/1410)

## Copyright/license

This document is licensed under the Apache License, Version 2.0 -- see [LICENSE](../LICENSE) or (https://www.apache.org/licenses/LICENSE-2.0)
